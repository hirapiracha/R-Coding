---
title: "Lecture 3"
author: "Marc Kaufmann"
date: "10/01/2024"
output: html
editor: 
  markdown: 
    wrap: 72
---

This lecture follows the first edition of [Grolemund and Wickham,
chapter 5](https://r4ds.had.co.nz/transform.html).

In addition to the `tidyverse`, we will need the `nycflights13`
package - you can check if you have it by trying to load it via
`library(nycflights13)`. Otherwise install it (not in this file, in the
console).

```{r load-nycflights}

```

Now explore the data to get a sense:

```{r look-at-nycflights}
#| eval: FALSE

```

Today, we'll cover the first verbs of the `dplyr` (data pliers) package,
which is part of the `tidyverse`:

-   filter(): selecting those rows that we are interested in
-   arrange(): ordering the rows
-   select(): selecting the columns that we are interested in

After that, we'll cover the remaining ones:

-   mutate(): changing the values across rows
-   summarise(): creating summary tables
-   group_by(): changing or summarising by groups

All these commands take as first argument a data frame (or tibble) and
return a data frame (or tibble). Together they form the verbs of the
tidyverse. This enables a nice workflow as we will see later.

## Filtering (choosing) rows with filter()

```{r basic-filter}
# What format is dep_time in?
```

Note that `dplyr` functions don't change the data frame that you give
it. They return a new one.

```{r not-changed}
flights 

# Save the filtered data 

# Assign and print, use (varname <- ...) 

# Check it really assigned 

```

## Some notes on comparisons

Before moving on, we need to look at how comparisons behave in R, since
it often affects which rows you get when filtering:

```{r comparisons}
sqrt(2)^2 == 2 
sqrt(4)^2 == 4 
(1/3)*3 == 1 
1/49*49 == 1 
1/(7^9)*7^9 == 1 

# For floating point comparisons, use near() to compare numbers 

```

The lesson is that you can't rely on "It works because it works for what
I tried".

**Exercise:** What counts as near? Find out. Can you change it?

## Multiple constraints

You will often want to `filter` on several constraints at the same time.
We can use the `|` ('or'), `&` ('and'), and `!` ('not') operators for
this. However, for 'and', we can simply specify multiple constraints by
default:

```{r or-and-and}
#| eval: FALSE
# Month is january and day is 4
(jan_4a <- filter(flights, ...))
(jan_4b <- filter(flights, ...))

# Month is 1 or 2
(jan_feb <- filter(flights, ...)) 

# Month is not january
(not_jan <- filter(flights, ...)))
```

**Class exercise:** How do we know these actually worked? Should you
believe me?

```{r check-filter-worked}


```

# Class Exercise: What does this do?

```{r mystery-filter}
mystery_filter <- filter(flights, !(arr_delay > 120 | dep_delay > 120)) 
mystery_filter 
```

Vote:

1.  All flights that started and landed 120 minutes late
2.  All flights that started 120 minutes late or landed 120 minutes late
3.  All flights that started less than 120 minutes late or landed less
    than 120 minutes late
4.  All flights that started and landed less than 120 minutes late

To figure out, check what happens to the following 4 values, where the first number is the starting time and the second the landing time:

-   (140, 140)

-   (140, 0)

-   (0, 140)

-   (0, 0)

I claim it is the same as the following:

```{r mystery-filter2}
mystery_filter2 <- filter(flights, arr_delay <= 120, dep_delay <= 120) 
mystery_filter2
```

How to convince ourselves that the two are the same?

```{r compare-mystery-filters}

```


**Class Exercise:** Write the filter command for the third voting
option: all flights that started less than 120 minutes late or landed
less than 120 minutes late.

```{r start-and-land-lt-120}

```

**Class Exercise:** get all flights that departed with less than 120
minutes delay, but arrived with more than 120 minutes delay and plot a 
histogram.

```{r start-early-land-late}

```

Let's visualize the departure times of all planes and those that depart
early:

```{r }

```

## NA: Not Available

```{r NA}
NA > 5 
10 == NA     # Watch for RStudio's helpful message
NA == NA 
FALSE & NA 
TRUE & NA 
NA & FALSE
```

A nice example from R4DS. Let `x` be Mary's age. We don't know how old
she is.

```{r marys-age}
x <- NA
```

Let `y` be John's age. We don't know how old he is.

```{r johns-age}
y <- NA
```

Then, are John and Mary the same age?

```{r john-and-mary}
x == y
```

... (fill in)

```{r other-NA}
NA^0 
0 * NA

x <- NA
is.na(x) 
df <- tibble(x = c(1, NA, 3)) 
df 
# Filtering with NA's

filter(df, x > 1)
filter(df, x > 1 | is.na(x))


```

## arrange()

It usually helps to spot errors and search tables if we order them:

```{r arrange}
library(nycflights13)
arrange(flights, year, month, day)
arrange(flights, dep_delay)
arrange(flights, desc(dep_delay))

arrange(df, x)
arrange(df, desc(x))
arrange(df, desc(is.na(x)), desc(x))
arrange(df, -x)

arrange(
  tibble(s = c("a", "b", "bb", "aa", "bababa")), 
  s
)
x
is.na(x)
is.na(3)
is.na(NA)
is.na(NULL)
```

**Class exercise:** How can we get the missing values at the top? Use
`is.na()`

Let us use this to get the fastest flight:

```{r fastest-flight1}
colnames(flights)

arrange(flights, air_time)
```

# select()

We use `select` to extract the columns we want:

```{r select}
select(flights, year, month, day)

select(arrange(flights, air_time), air_time, origin, dest, tailnum)
```

That's tedious to write *and* difficult to read. The pipe solves this
problem.

```{r ceci-est-une-pipe}
#| eval: FALSE
flights |> 
  arrange(air_time) |>
  select(air_time, origin, dest)
```

Notice that the data doesn't have to be mentioned in the call, as it gets passed
around as the first argument automatically. Therefore we no longer provide the 
first argument.

`select` understands a variety of patterns to select or drop (i.e. not select) 
certain columns:

```{r select-multiple-columns}
# selecting all columns between two columns (bugs galore if columns reordered)
select(flights, year:day)

# dropping cols
select(flights, -(year:day))
select(flights, -c(year, month, day))

# Some helper functions
select(flights, starts_with("arr"))
select(flights, -starts_with("arr"))
select(flights, ends_with("hour"))
select(flights, contains("time"))

# Reordering columns by moving some columns to the start
select(flights, origin, dest, everything())
```

Apparently the way to reorder columns is now `relocate`, in particular 
when you move blocks of columns at once. See `?relocate`.

What does the following do? Is that as expected? 

```{r select-with-multiple-patterns}
select(flights, -contains("time"), starts_with("arr")) 
```

...

```{r select-matching-both-conditions}
flights |>
  select(-contains("time")) |>
  select(starts_with("arr"))

flights |>
  select(-contains("time") & starts_with("arr"))
```

See `?select` for other examples.

## Renaming columns

```{r rename}
my_renamed_flights <- flights |>
  rename(destination = dest) |>
  select(destination, everything())

flights
my_renamed_flights
```

To allow us to see that this worked, let's select fewer columns: 

```{r rename-visible}

```

**Class Exercise:** What happens if you include a variable multiple times?